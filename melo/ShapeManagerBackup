package melo;
import java.util.*;

class Point {
    double[] data;//1d 2d 3d points
    public Point(double[] dataTemp) {
        data = new double[dataTemp.length];
        for (int i = 0; i < data.length; i++) {
            data[i] = dataTemp[i]; 
        }
    }
    public Point(int x, int y) {
        data = new double[2];
        data[0] = x; 
        data[1] = y;
    }
    public Point(int x) {
        data = new double[1];
        data[0] = x; 
    }
    public double getData(int d) {
        return data[d];
    }
    //default 1d point
    public double getData() {
        return data[0];
    }
}

class Shape {
    Point[] points;
    int[] indexes;
    int dimension;
    int distanceMode;//0-absolute 1-shift
    public Shape(int[] indexes, Point[] points, int dimension, int distanceMode) {
        this.indexes = new int[indexes.length];
        this.distanceMode = distanceMode;
        this.dimension = dimension;
        for (int i = 0; i < indexes.length; i++) {
            this.indexes[i] = indexes[i];
        }
        this.points = points;
    }
    public int getDimension() {
        return dimension;
    }
    public int getLength() {
        return points.length;
    }
    public double getData(int index, int dimension) {
        return points[index].getData(dimension);
    }
    public double getData(int index) {
        return points[index].getData();
    }
    public double calDistance(Shape s) {
        int dimension = s.getDimension();
        if (dimension == 1) {
            int n = getLength();
            double shift = 0;
            if (distanceMode == 1) {
                double temp = 0;
                for (int i = 0; i < n; i++) {
                    double xi = getData(i);
                    double yi = s.getData(i);
                    temp += xi-yi;
                }
                shift = -temp / n;
            } 
            double total = 0;
            for (int i = 0; i < n; i++) {
                double xi = getData(i);
                double yi = s.getData(i);
                total += (xi-yi+shift)*(xi-yi+shift);
            }
            return Math.sqrt(total) / n;
        } else if (dimension == 2) {
        }
        System.out.println("Wrong dimension");
        return -1;
    }
}


public class ShapeManager {
    private int groupSelection; //0-onlyself 1-inv 2-retro 3-retroInv 4-all
    private boolean hasCalInv, hasCalRetro, hasCalRetroInv;
    private double[][] minDis; //minimal distance between shape i and j
    private double[][] selfDis, invDis, retroDis, retroInvDis;
    private List<Shape> selfShapes, invShapes, retroShapes, retroInvShapes;
    public ShapeManager(boolean containInv, boolean containRetro, boolean containRetroInv, List<Shape> selfShapes, List<Shape> invShapes, List<Shape> retroShapes, List<Shape> retroInvShapes) {
        groupSelection = 0; //default
        hasCalInv = hasCalRetro = hasCalRetroInv = false;
        int n = shapes.size();
        minDis= selfDis = invDis = retroDis = retroInvDis = new double[n][n];
        whetherGroupChanged(containInv, containRetro, containRetroInv);
        calSelfDis();
    }
    boolean whetherGroupChanged(boolean containInv, boolean containRetro, boolean containRetroInv) {
        int count = 0;
        if (containInv) count++;
        if (containRetro) count++;
        if (containRetroInv) count++;
        if (count == 0) {
            if (groupSelection != 0) {
                groupSelection = 0;
                return true;
            }
            return false;
        } else if (count == 1) {
            //doesn't change
            if (containInv && groupSelection == 1) { return false;}
            if (containRetro && groupSelection == 2) { return false;}
            if (containRetroInv && groupSelection == 3) { return false;}
            //changed
            if (containInv) { 
                groupSelection = 1;
            } else if (containRetro) {
                groupSelection = 2;
            } else {
                groupSelection = 3;
            }
            return true;
        }
        if (groupSelection == 4) { return false;}
        groupSelection = 4;
        return true;
    }
    public void resetContainGroups(boolean containInv, boolean containRetro, boolean containRetroInv) {
        //group selection change, update minDistance
        if (whetherGroupChanged(containInv, containRetro, containRetroInv)) {
            calMinDis(groupSelection);
        }
    }
    public void calMinDis(int groupSelection) {
        //updateInv
        if ((groupSelection == 1 || groupSelection == 4) && !hasCalInv) {
            calInvDis();
        }
        if ((groupSelection == 2 || groupSelection == 4) && !hasCalRetro) {
            calRetroDis();
        }
        if ((groupSelection == 3 || groupSelection == 4) && !hasCalRetroInv) {
            calRetroInvDis();
        }
    }
    void calSelfDis() {
        System.out.println("Calculate P*P");
        for (int i = 0; i < selfShapes.size(); i++) {
            for (int j = i + 1; j < selfShapes.size(); j++) {
                selfDis[i][j] = selfDis[j][i] = selfShapes.get(i).calDistance(selfShapes.get(j));
            }
        }
    }
    void calInvDis() {
        System.out.println("Calculate P*I");
        for (int i = 0; i < selfShapes.size(); i++) {
            for (int j = i + 1; j < invShapes.size(); j++) {
                invDis[i][j] = invDis[j][i] = selfShapes.get(i).calDistance(invShapes.get(j));
            }
        }
        hasCalInv = true;
    }
    void calRetroDis() {
        System.out.println("Calculate P*R");
        for (int i = 0; i < selfShapes.size(); i++) {
            for (int j = i + 1; j < retroShapes.size(); j++) {
                retroDis[i][j] = retroDis[j][i] = selfShapes.get(i).calDistance(retroShapes.get(j));
            }
        }
        hasCalRetro = true;
    }
    void calRetroInvDis() {
        System.out.println("Calculate P*RI");
        for (int i = 0; i < selfShapes.size(); i++) {
            for (int j = i + 1; j < retroInvShapes.size(); j++) {
                retroInvDis[i][j] = retroInvDis[j][i] = selfShapes.get(i).calDistance(retroInvShapes.get(j));
            }
        }
        hasCalRetroInv = true;
    }
    public int getGroupSelection() {
        return groupSelection;
    }

    public static void main(String[] args) {

        //the points for first shape in 1D line 
        Point[] points1 = new Point[3];
        points1[0] = new Point(-1);
        points1[1] = new Point(1);
        points1[2] = new Point(0);

        //the points for second shape in 2-D panel, x increases (onset)
        Point[] points2 = new Point[3];
        points2[0] = new Point(0);
        points2[1] = new Point(1);
        points2[2] = new Point(-1);

        List<Shape> shapes = new ArrayList<Shape>();
        System.out.println("Normal shape");
        shapes.add(new Shape(new int[]{0,1,2},points1,1,0)); 
        shapes.add(new Shape(new int[]{0,1,5},points2,1,0)); 
        System.out.println(shapes.get(0).calDistance(shapes.get(1)));

        List<Shape> shapes2 = new ArrayList<Shape>();
        System.out.println("Shifted shape");
        shapes2.add(new Shape(new int[]{0,1,2},points1,1,1)); 
        shapes2.add(new Shape(new int[]{0,1,5},points2,1,1)); 
        System.out.println(shapes2.get(0).calDistance(shapes2.get(1)));
    }
}
